{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>This website is under construction.</p> <p>Named Data Networking (NDN)<sup>1</sup> is a future Internet architecture inspired by years of research into network usage and a growing awareness of unsolved problems in the contemporary protocols. Many of these problems arise due to the fundamental mismatch between the data-centric usage of the Internet and the host-centric nature of IP. NDN is designed as a data-centric replacement of the TCP/IP architecture, thus overcoming this mismatch by replacing the network layer itself. The NDN project is now a collaborative effort of a large community of researchers at more than a dozen institutions.</p> <p>NDN retains the Internet's hourglass architecture but evolves the thin waist to allow the creation of completely general distribution networks. The core element of this evolution is removing the restriction that packets can only identify communication endpoints. As far as the network is concerned, the identifier in an NDN packet can be anything \u2014 an endpoint, a chunk of movie or book, a command to turn on some lights, etc. This conceptually simple change allows NDN networks to use almost all of the Internet\u2019s well understood and well tested engineering properties to efficiently solve not only communication problems but also digital distribution and control problems.</p> <p>A more detailed discussion can be found at the website of the NDN project (named-data.net)</p> <p>The design of NDN naturally leads to several advantages over IP and IP-based protocols. Some of these are briefly described below.</p> <ul> <li> <p>Data-Centric Security: NDN provides data-centric security<sup>2</sup> where it secures data directly rather than relying on securing the channels that transmit the data. Each packet of data carries a cryptographic signature that binds the name, contents and the identity of the producer of the data.</p> </li> <li> <p>Privacy: NDN provides privacy by allowing consumers to retrieve data without needing to expose their identity to the network. This is in contrast to IP where the source and destination addresses are exposed in every packet.</p> </li> <li> <p>Name-based Forwarding: NDN packets are routed and forwarded using their names. This allows NDN routers to make forwarding decisions based on application semantics rather than just network addresses. This also directly provides support for anycast for applications.</p> </li> <li> <p>Intelligent Data Plane: NDN utilizes a stateful forwarding plane where forwarders track the requests and responses of data. This allows NDN to support a wide range of advanced features such as adaptive and multipath forwarding, and provides DDoS protection<sup>3</sup> and congestion control<sup>4</sup> at the network layer.</p> </li> <li> <p>Multicast and Caching: The stateful forwarding plane allows for aggregation of requests and responses, which enables efficient multicast of all Data packets. Since NDN packets are individually secured and do not rely on channel security, data is also securely cached at every forwarder in the network, creating a massive distributed cache.</p> </li> </ul> <p>The NDN project also maintains a large open source code base, with NDN forwarders, debugging tools and libraries available in multiple languages including C++, Python, Go, TypeScript etc. Most of this code is available at the GitHub.</p> <ol> <li> <p>Zhang, L. et al. 2014. Named Data Networking. ACM SIGCOMM Computer Communication Review (CCR). 44, 3 (2014), 66\u201373. DOI:https://doi.org/10.1145/2656877.2656887.\u00a0\u21a9</p> </li> <li> <p>Zhang, Z. et al. 2018. An overview of security support in named data networking. IEEE Communications Magazine. 56, 11 (2018), 62\u201368. DOI:https://doi.org/10.1109/MCOM.2018.1701147.\u00a0\u21a9</p> </li> <li> <p>Gasti, P. et al. 2013. DoS and DDoS in named data networking. 2013 22nd international conference on computer communication and networks (ICCCN) (2013), 1\u20137.\u00a0\u21a9</p> </li> <li> <p>Song, S. and Zhang, L. 2022. Effective NDN congestion control based on queue size feedback. Proceedings of the 9th ACM conference on information-centric networking (New York, NY, USA, 2022), 11\u201321.\u00a0\u21a9</p> </li> </ol>"},{"location":"communication/","title":"Communication","text":"<p>NDN applications fetch data using Interest-Data packet exchanges. The process of such an exchange can be summarized as follows:</p> <ol> <li>An application that desires a piece of data sends an Interest packet.      The Interest packet contains the name of the data being requested.</li> <li>The network forwards the Interest packet to the node(s) having a copy of the data.</li> <li>On receiving the Interest packet, a node may reply with a matching Data packet.</li> <li>The network the forwards this Data packet back to the requesting application.</li> </ol> <p>Types of Applications</p> <p>Applications that send Interests to fetch data packets are called \"consumers\". Likewise, applications that serve Data in response to Interests are called \"producers\". An application may act as both a consumer and a producer simultaneously.</p>"},{"location":"communication/#consumer","title":"Consumer","text":"<p>Consumers are applications that send Interest packets to fetch data. The Interest packet contains the name of the data being requested along with any optional selectors. The following snippet illustrates how to send an Interest packet and get back the corresponding Data.</p> <p>For this example to work, you must first run the producer from the next part.</p> ndn-cxxpython-ndnNDNts <pre><code>#include &lt;iostream&gt;\n#include &lt;ndn-cxx/face.hpp&gt;\n\nint main(int argc, char** argv)\n{\n    // Create an Interest packet\n    ndn::Interest interest(\"/edu/ucla/cs/118/notes\");\n\n    // Connect to the local forwarder over a Unix socket\n    ndn::Face face;\n\n    // Send the Interest packet and get back the Data packet\n    face.expressInterest(interest,\n                        [](const ndn::Interest&amp;, const ndn::Data&amp; data) {\n                            // Received a Data packet reply\n                            std::cout &lt;&lt; data &lt;&lt; std::endl;\n                        },\n                        [](const ndn::Interest&amp;, const ndn::lp::Nack&amp; nack) {\n                            // Received a Nack (negative acknowledgement)\n                            std::cout &lt;&lt; \"Nack received: \" &lt;&lt; nack.getReason() &lt;&lt; std::endl;\n                        },\n                        [](const ndn::Interest&amp;) {\n                            // The Interest has timed out\n                            std::cout &lt;&lt; \"Timeout\" &lt;&lt; std::endl;\n                        });\n\n    // Start face processing loop\n    face.processEvents();\n}\n</code></pre> <pre><code>from ndn.app import NDNApp\nfrom ndn.encoding import Name\n\n# Connect to the local forwarder over a Unix socket\napp = NDNApp()\n\nasync def main():\n    try:\n        data_name, meta_info, content = await app.express_interest(\"/edu/ucla/cs/118/notes\")\n\n        # Received a Data packet\n        print(f'Received Data Name: {Name.to_str(data_name)}')\n        print(meta_info)\n        print(bytes(content) if content else None)\n\n    except InterestNack as e:\n        # Received a Nack (negative acknowledgement)\n        print(f'Nacked with reason={e.reason}')\n    except InterestTimeout:\n        # The Interest has timed out\n        print(f'Timeout')\n    except InterestCanceled:\n        # Connection to the local NDN forwarder is broken\n        print(f'Canceled')\n    except ValidationFailure:\n        # Security validation failed for the data\n        print(f'Data failed to validate')\n\n    finally:\n        # Disconnect from the local forwarder\n        app.shutdown()\n\nif __name__ == '__main__':\n    app.run_forever(after_start=main())\n</code></pre> <pre><code>import { Interest } from '@ndn/packet';\nimport { WsTransport } from '@ndn/ws-transport';\nimport { Endpoint } from '@ndn/endpoint';\n\n// Code running in the browser cannot connect to a local Unix socket.\n// In this example, we connect to a remote NFD instance, running as\n// a part of the global NDN testbed.\nconst uplink = await WsTransport.createFace({}, \"wss://suns.cs.ucla.edu/ws/\");\nconsole.log(`Connected to NFD at ${uplink.remoteAddress}`);\n\n// Construct an Endpoint on the default forwarder instance.\nconst endpoint = new Endpoint();\n\n// Create an Interest packet\nconst interest = new Interest(`/ndn/edu/arizona/ping/NDNts/${Date.now()}`);\n\n// Send the Interest packet and wait for the Data packet\ntry {\n    const data = await endpoint.consume(interest);\n    console.log(`Received data with name [${data.name}]`);\n} catch (err: any) {\n    console.warn(err);\n}\n\n// Disconnect from the remote NFD instance\nuplink.close();\n</code></pre>"},{"location":"communication/#producer","title":"Producer","text":"<p>To serve data to other applications, a producer must register a name prefix with the network.</p> <ol> <li>The producer sends a registration request to the network carrying a name prefix.</li> <li>A route to the prefix is registered at the local forwarder, and may be propagated to other forwarders in the network.</li> <li>The producer is notified of the successful registration.</li> <li>Any Interest packets matching the prefix may now be forwarded to the producer.</li> </ol> <p>The following snippet illustrates how to serve data by registering a name prefix route at the local forwarder. Make sure to start NFD on your development machine before running this example.</p> ndn-cxxpython-ndnNDNts <pre><code>#include &lt;iostream&gt;\n#include &lt;ndn-cxx/face.hpp&gt;\n#include &lt;ndn-cxx/security/key-chain.hpp&gt;\n\nint main(int argc, char** argv)\n{\n    // Connect to the local forwarder over a Unix socket\n    ndn::Face face;\n\n    // Connect to the local KeyChain to sign Data packets\n    // Note: Security is not optional in NDN\n    ndn::KeyChain keychain;\n\n    // Register a prefix with the local forwarder\n    face.setInterestFilter(\"/edu/ucla/cs/118/notes\",\n        [&amp;face, &amp;keychain](const ndn::InterestFilter&amp;, const ndn::Interest&amp; interest) {\n            std::cout &lt;&lt; \"Received Interest packet for \" &lt;&lt; interest.getName() &lt;&lt; std::endl;\n\n            // Create a Data packet with the same name as the Interest\n            ndn::Data data(interest.getName());\n\n            // Set the Data packet's content to \"Hello, World!\"\n            data.setContent(ndn::make_span(reinterpret_cast&lt;const uint8_t*&gt;(\"Hello, NDN!\"), 11));\n\n            // Sign the Data packet with default identity\n            keychain.sign(data);\n\n            // Return the Data packet to the network\n            face.put(data);\n        },\n\n        // Register prefix failure handler -- optional\n        nullptr,\n\n        // Register prefix failure handler\n        [](const ndn::Name&amp; prefix, const std::string&amp; reason) {\n            std::cout &lt;&lt; \"Route registration failed\" &lt;&lt; std::endl;\n        });\n\n    // Start face processing loop\n    face.processEvents();\n}\n</code></pre> <pre><code>from typing import Optional\nfrom ndn.app import NDNApp\nfrom ndn.encoding import Name, InterestParam, BinaryStr, FormalName\n\n# Connect to the local forwarder over a Unix socket\napp = NDNApp()\n\n# Register a prefix, and call on_interest when a matching Interest is received\n@app.route('/edu/ucla/cs/118/notes')\ndef on_interest(name: FormalName, param: InterestParam, _app_param: Optional[BinaryStr]):\n    print(f'Received Interest packet for {Name.to_str(name)}')\n\n    # Create the content bytes for the Data packet\n    content = \"Hello, NDN!\".encode()\n\n    # Sign and send the Data packet back to the network\n    app.put_data(name, content=content, freshness_period=10000)\n\nif __name__ == '__main__':\n    app.run_forever()\n</code></pre> <pre><code>import { Data, digestSigning } from '@ndn/packet';\nimport { WsTransport } from '@ndn/ws-transport';\nimport { Endpoint } from '@ndn/endpoint';\nimport { toUtf8 } from '@ndn/util';\n\n// Code running in the browser cannot connect to a local Unix socket.\n// In this example, we connect to a remote NFD instance, running as\n// a part of the global NDN testbed.\nconst uplink = await WsTransport.createFace({}, \"wss://suns.cs.ucla.edu/ws/\");\nconsole.log(`Connected to NFD at ${uplink.remoteAddress}`);\n\n// Construct an Endpoint on the default forwarder instance.\nconst endpoint = new Endpoint();\n\n// Start one producer\nconst myProducer = endpoint.produce('/edu/ucla/cs/118/notes', async (interest) =&gt; {\n    console.log(`Received Interest packet for ${interest.name.toString()}`);\n    // Create the content bytes for the Data packet\n    const content = toUtf8(\"Hello, NDN!\");\n    // Sign and send the Data packet back to the network\n    const data = new Data(interest.name, Data.FreshnessPeriod(10000), content);\n    await digestSigning.sign(data);\n    return data;\n});\n</code></pre>"},{"location":"communication/#faces","title":"Faces","text":"<p>Under Construction</p>"},{"location":"debugging/","title":"Debugging","text":"<p>This page is under construction.</p>"},{"location":"forwarding/","title":"Forwarding Plane","text":"<p>NDN uses a stateful forwarding plane<sup>1</sup> that maintains several tables at forwarders. This is in contrast to the stateless forwarding plane of IP, which does not maintain any per-packet state. The stateful forwarding plane of NDN enables Data multicast and caching, along with other features such as privacy, loop detection, network-layer congestion control<sup>2</sup> and DoS protection<sup>3</sup>.</p> <p>Each instance of NFD in an NDN network maintains several tables. Some of these tables store per-packet state, thus making the forwarding plane stateful. The most important of these tables are described briefly in the following sections.</p> <p>Further Reading</p> <p>If you are interested in the implementation details of NFD, please refer to the NFD Developer Guide.</p>"},{"location":"forwarding/#forwarding-information-base","title":"Forwarding Information Base","text":"<p>The FIB is a forwarding table similar to the one found in IP routers, which maps name prefixes to outgoing faces. It is used by NFD to forward Interest packets. Each entry in the FIB contains the following information.</p> <ul> <li>A name prefix.</li> <li>A set of next hops (outgoing faces).</li> <li>The cost of each next hop face.</li> </ul> <p>When NFD receives an Interest which must be forwarded, it looks up the FIB for the longest matching prefix. If a matching entry is found, the Interest may be forwarded to one or more faces specified in the entry. The exact decision of which face(s) to forward the Interest on is made by the strategy matching the prefix, as described in the next section.</p>"},{"location":"forwarding/#strategy-table","title":"Strategy Table","text":"<p>The strategy table is used by NFD to decide which strategy to use for forwarding a given Interest. Each entry in the strategy table contains the following information.</p> <ul> <li>A name prefix.</li> <li>The name of the strategy to use for forwarding Interests matching the prefix.</li> </ul> <p>When NFD receives an Interest which must be forwarded, it looks up the strategy table for the longest matching prefix. The matching strategy is then used to decide which face(s) to forward the Interest on.</p> <p>Some examples of strategies are,</p> <ul> <li>Best route: Use the next hop with the lowest cost.</li> <li>Multicast: Forward the Interest to all next hops.</li> <li>ASF: Use the Adaptive Smoothed RTT-based Forwarding (ASF) algorithm<sup>4</sup>.</li> </ul>"},{"location":"forwarding/#pending-interest-table","title":"Pending Interest Table","text":"<p>The PIT is the most important table in the forwarding plane, and it provides the basic support for the pull model of communication in NDN.</p> <p>When NFD receives an Interest, it stores a PIT entry in this table. Each PIT entry contains the following information.</p> <ul> <li>The name of the Interest along with any selectors.</li> <li>The incoming face on which the Interest was received (in-record).</li> <li>The outgoing face(s) on which the Interest was forwarded (out-record).</li> <li>The time at which the Interest will expire (lifetime).</li> </ul> <p>On receiving a Data packet, NFD performs the following steps.</p> <ul> <li>Looks up the PIT for an entry matching the Data packet.</li> <li>If such an entry is found, the Data packet is forwarded on the incoming face     of the PIT entry, and the PIT entry is removed from the table.</li> <li>If no matching PIT entry is found, the Data packet is dropped.</li> </ul> <p>The PIT entry is also dropped if the Interest times out before a matching Data packet is received.</p> <p>One-Interest One-Data</p> <p>A fundamental principle of NDN is that one outgoing Interest can bring back at most one Data packet. This is enforced by the PIT, since the PIT entry is removed from the table as soon as a matching Data packet is received and forwarded to the incoming face.</p> <p>Breadcrumb Trail</p> <p>In an NDN network containing multiple forwarders, PIT entries for an Interest serve as a breadcrumb trail that the Data packet follows back to the consumer. As a result, no source address is required in the Interest packet for sending the Data packet back to the consumer.</p> <p>Implementation of PIT</p> <p>For efficiency, forwarders may implement the PIT using tree-based data structures or hash tables. The entry expiration is typically implemented using priority queues.</p>"},{"location":"forwarding/#data-multicast","title":"Data Multicast","text":"<p>The per-packet statefulness of the PIT directly enables Data multicast by allowing a single Data packet to be forwarded to multiple consumers that have expressed an Interest in the same data.</p> <p>When NFD receives an Interest, it first looks up the PIT for an entry matching the Interest. If such an entry is found, the Interest is aggregated with the existing entry, by appending an in-record to the entry for the incoming face of the new Interest. The Interest is then not forwarded further.</p> <p>When a matching Data packet is received, it is forwarded on all the incoming faces of the PIT entry. As a result, multiple Interests are satisfied with a single Data packet, thus realizing Data multicast.</p> <p>Multicast and Interest Selectors</p> <p>Interests can generally be aggregated only if they have the same name and selectors. For instance, two Interests having the same name but different values for the <code>MustBeFresh</code> selector cannot be aggregated, since they are potentially requesting different Data packets.</p>"},{"location":"forwarding/#consumer-privacy","title":"Consumer Privacy","text":"<p>Since the PIT stores the incoming face of each Interest, the outgoing Interest does not need to contain any information about the incoming face. This enables consumer privacy in NDN, by ensuring that Interest packets cannot be used to identify the original sender.</p>"},{"location":"forwarding/#loop-detection","title":"Loop Detection","text":"<p>The PIT also lets NFD detect and prevent looping Interests. Each Interest in NDN carries a randomly generated nonce, which is stored in the PIT entry along with the Interest name. When NFD receives an Interest, it first looks up the PIT for an entry matching the Interest. If such an entry is found including a matching nonce, then the incoming Interest is dropped.</p> <p>Longer Loops</p> <p>While the PIT prevents some types of looping Interests, it fails to detect longer loops, since an Interest may be satisfied by a Data packet before it loops back to the same forwarder. To detect such looping Interests, NFD uses a separate table called the Dead Nonce List, which stores nonces of recently satisfied Interests.</p>"},{"location":"forwarding/#content-store","title":"Content Store","text":"<p>The Content Store is a cache of Data packets, which is used by NFD to satisfy Interests. When NFD receives an Interest, it first looks up the Content Store for a matching Data packet before looking up the FIB and Strategy Tables. If a matching Data packet is found, it is directly used to satisfy the Interest, and the Interest is not forwarded further.</p> <p>The Content Store is a key component of NDN, since it enables Data caching at the network layer. As a result, NDN supports both synchronous and asynchronous multicast of Data packets.</p> <p>Data Freshness</p> <p>NDN Data packets carry a <code>FreshnessPeriod</code>, which specifies the time in milliseconds for which the data is fresh. A Data packet cached earlier than its freshness period is considered \"non-fresh\", and cannot be used to satisfy Interests with the <code>MustBeFresh</code> selector.</p> <ol> <li> <p>Yi, C. et al. 2013. A case for stateful forwarding plane. Computer Communications. 36, 7 (2013), 779\u2013791. DOI:https://doi.org/https://doi.org/10.1016/j.comcom.2013.01.005.\u00a0\u21a9</p> </li> <li> <p>Song, S. and Zhang, L. 2022. Effective NDN congestion control based on queue size feedback. Proceedings of the 9th ACM conference on information-centric networking (New York, NY, USA, 2022), 11\u201321.\u00a0\u21a9</p> </li> <li> <p>Gasti, P. et al. 2013. DoS and DDoS in named data networking. 2013 22nd international conference on computer communication and networks (ICCCN) (2013), 1\u20137.\u00a0\u21a9</p> </li> <li> <p>Lehman, V. et al. 2016. An experimental investigation of hyperbolic routing with a smart forwarding plane in NDN. 2016 IEEE/ACM 24th international symposium on quality of service (IWQoS) (2016), 1\u201310.\u00a0\u21a9</p> </li> </ol>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This page will guide you through the process of installing the basic tools needed to start using and developing NDN applications.</p>"},{"location":"getting-started/#packet-forwarder","title":"Packet Forwarder","text":"<p>To begin, you will need to first install the NDN Forwarding Daemon (NFD) on your computer. There are several implementations of NFD, the most popular of which are:</p> <ul> <li>NFD<sup>1</sup>, the reference implementation (C++)</li> <li>YaNFD<sup>2</sup>, a multithreaded implementation (Golang)</li> <li>NDN-DPDK<sup>3</sup>, a high-performance implementation (C)</li> <li>NDN-Lite<sup>4</sup>, an IoT implementation (C)</li> </ul> <p>What is the role of NFD?</p> <p>NFD is the NDN equivalent of an IP \"router\", and runs on each node in the network. It is responsible for forwarding NDN packets between nodes, including functions of Data multicast and caching.</p>"},{"location":"getting-started/#client-library","title":"Client Library","text":"<p>Next, you will need to install a client library of your choice to interact with the NDN network. Depending on the library, you will need the corresponding compilers / interpreters / build tools.</p> <ul> <li>ndn-cxx (C++) [Docs, API]</li> <li>python-ndn (Python) [Docs]</li> <li>NDNts (TypeScript) [Docs]</li> <li>go-ndn (Golang)</li> <li>NDN-Lite (C, IoT) [Docs, API]</li> <li>esp8266ndn (Arduino) [API]</li> </ul> <p>What does the client library do?</p> <p>The client library provides the NDN equivalent of a TCP/IP \"socket\", and runs inside each application. It is responsible for encoding and decoding NDN packets, and sending / receiving them to / from NFD.</p> <p>Once you have installed NFD and a client library, you need to start NFD on your local development machine. You are now ready to start developing NDN applications!</p> <p>Contributing to the NDN codebase</p> <p>The NDN codebase is free and open-source software, and most of it is available on GitHub. If you are interested in contributing, make sure you read this guide and the code of conduct first.</p>"},{"location":"getting-started/#debugging-tools","title":"Debugging Tools","text":"<p>The ndn-tools package is highly recommended and contains several tools for developing and debugging NDN applications.</p> <ul> <li>peek: transmit a single Interest/Data packet between a consumer and a producer.</li> <li>chunks: segmented file transfer between a consumer and a producer.</li> <li>ping: test reachability between two NDN nodes</li> <li>dump: capture and analyze live traffic on an NDN network</li> <li>dissect: inspect the TLV structure of an NDN packet</li> <li>dissect-wireshark: Wireshark extension to inspect the TLV structure of NDN packets</li> </ul> <p>Ping test for NFD</p> <p>You can run a simple test for your local NFD by using thee ndn-tools package to start a ping server and client on the same machine. These will then communicate by connecting to NFD over a unix socket.</p> <pre><code>ndnpingserver /my/nfd/test &amp;\nndnping /my/nfd/test\n</code></pre>"},{"location":"getting-started/#getting-help","title":"Getting Help","text":"<p>If you have any questions about NDN or the code base, we encourage you to reach out to the community for help. Some options include,</p> <ul> <li>Ask a question at the most appropriate mailing list.</li> <li>File an issue at the relevant GitHub repository or Redmine.</li> <li>(If applicable) reach out to the authors of the paper that introduced the software.</li> </ul> <ol> <li> <p>Afanasyev, A. et al. 2014. NFD developer\u2019s guide. Dept. Comput. Sci., Univ. California, Los Angeles, Los Angeles, CA, USA, Tech. Rep. NDN-0021. 29, (2014), 31.\u00a0\u21a9</p> </li> <li> <p>Newberry, E. et al. 2021. YaNFD: Yet another named data networking forwarding daemon. Proceedings of the 8th ACM conference on information-centric networking (New York, NY, USA, 2021), 30\u201341.\u00a0\u21a9</p> </li> <li> <p>Shi, J. et al. 2020. NDN-DPDK: NDN forwarding at 100 gbps on commodity hardware. Proceedings of the 7th ACM conference on information-centric networking (New York, NY, USA, 2020), 30\u201340.\u00a0\u21a9</p> </li> <li> <p>Zhang, Z. et al. 2018. NDNoT: A framework for named data network of things. Proceedings of the 5th ACM conference on information-centric networking (New York, NY, USA, 2018), 200\u2013201.\u00a0\u21a9</p> </li> </ol>"},{"location":"ndn-security/","title":"Security","text":"<p>This page is under construction.</p> <p>Security is baked into the core of NDN, and is a fundamental part of the architecture. NDN utilizes a data-centric name-based security model, where every piece of data is signed by its producer. This allows NDN to provide data-centric security, privacy, and trustworthiness. The following sections provide an overview of the security features of NDN.</p>"},{"location":"ndn-security/#signature","title":"Signature","text":"<p>In NDN, every Data packet is digitally signed by its producer. The signature guarantees the integrity of the packet, because the signature can only be generated by the original producer, and becomes invalid if the encoded packet is modified.</p> <p>Digital signing is done by a pair of asymmetric keys, which consists of a private key and a public key. The private key is known only by the producer, used to generate signatures. Anyone who knows the public key can verify the signature.</p> python-ndnNDNts <pre><code>import ndn.encoding as enc\nimport ndn.security as sec\nfrom Cryptodome.PublicKey import ECC\n\n# Generate key pairs (Recommend 'P-256' for ECDSA and 'ed25519' for EdDSA)\npriv_key = ECC.generate(curve='ed25519')\npub_key = priv_key.public_key()\n# Create a signer\nsigner = sec.Ed25519Signer('/edu/ucla/xinyu.ma', priv_key.export_key(format='DER'))\n# Sign a data with it\ndata_wire = enc.make_data(\n    # String can be directly used as Name in most cases\n    name='/edu/ucla/cs/118/notes',\n    # Set the Interest packet's FreshnessPeriod to 10 seconds\n    meta_info=enc.MetaInfo(freshness_period=10000),\n    # Set the Data packet's content to \"Hello, NDN!\"\n    content=b'Hello, NDN!',\n    signer=signer\n)\nprint('Data:', data_wire.hex())\n\n# Export public keys\npub_key_bits = pub_key.export_key(format='DER')\nprint('Public Key bits:', pub_key_bits.hex())\n# Can be imported by: ECC.import_key(pub_key_bits)\n\n# Then verify the Data packet using it\n_, _, _, sig_ptrs = enc.parse_data(data_wire)\nif sec.verify_ed25519(pub_key, sig_ptrs):\n    print('Data verified')\nelse:\n    print('Data not verified')\n</code></pre> <pre><code>import { Data, Name } from '@ndn/packet';\nimport { Decoder, Encoder } from '@ndn/tlv';\nimport { toHex, toUtf8 } from '@ndn/util';\nimport { Ed25519, generateSigningKey } from '@ndn/keychain';\n\n// Generate key pairs (Recommend ECDSA and Ed25519 for EdDSA)\nconst identityName = new Name('/edu/ucla/xinyu.ma');\nconst [signer, verifier] = await generateSigningKey(identityName, Ed25519);\n// Sign a Data with it\nconst data = new Data(\n  new Name('/edu/ucla/cs/118/notes'),\n  Data.FreshnessPeriod(10000),\n  toUtf8('Hello, NDN!'));\nawait signer.sign(data);\n// Print the Data wire\nconst wire = Encoder.encode(data);\nconsole.log('Data:', toHex(wire));\n\n// Export public keys\nconst publicKeyBits = verifier.spki!;\nconsole.log('Public Key bits:', toHex(publicKeyBits));\n// Importing a public key in NDNts is very complicated \n// so I recommend to use a certificate instead.\n// I will show you how to do it later.\n\n// Then verify the Data packet using it\nconst decodedData = Decoder.decode(wire, Data); // Be the same as `data`\ntry {\n  await verifier.verify(decodedData);\n  console.log('Data verified');\n} catch {\n  console.log('Data not verified');\n}\n</code></pre> <p>In a system, security is more than cryptographically verifying the signature. For example, we also need to</p> <ul> <li>Securely obtain the public key of the producer.<ul> <li>A signed piece of data containing the pubic key is called a certificate.</li> </ul> </li> <li>Associate the producer with a member (human or process) in the system.</li> <li>Make sure the member is allowed to sign the data.</li> </ul> <p>These tasks can be roughly classified into four aspects:</p> <ul> <li>Bootstrapping: to enroll a new member into an application. Make sure that the new member learns necessary security information to recognize others, and the other members are able to securely recognize new member.</li> <li>Management: to manage the membership and certificates, including certification revocation, renewal, and other operations.</li> <li>Authentication: to verify a piece of data is produced by claimed producer and not manipulated by an impersonator.     This includes cryptographically verifying the signature.</li> <li>Authorization: a piece of data is produced by an intended producer, and accessed by an intended consumer.     This includes discarding of data whose producers are not allowed to produce, and encrypting data so that only permitted consumers can decrypt.</li> </ul> <p>The classification described is not strict. Most work on NDN involves more than one aspects of the security.</p>"},{"location":"ndn-security/#trust-domain","title":"Trust Domain","text":"<p>A trust domain is a collection of named entities under the same administrative control. For example, if a research group uses some NDN software to write papers, then the papers and users' certificates involved in that software makes a trust domain.</p> <p>A trust zone is usually configured with a trust anchor, a self-signed certificate whose name prefix reflects the name of the trust domain. The trust anchor is called an \"anchor\" because all trust relations in the domain starts from it. Suppose in the above paper writing example, the professor uses an admin certificate to sign student's public key, and students uses their own key to sign changes they make to the paper. Then, we have the following chain of signing:</p> <pre><code>flowchart LR\n    Admin --&gt;|signs| Student --&gt;|signs| paper[Paper Changes]</code></pre> <p>All signatures start from the admin's certificate if we transitively follow the chain of signing. The entity (member or process) that owns the trust anchor has the power to control all trust relations within the trust domain. Entities managing the trust relationship of the trust domain (including memberships and roles) are called controllers. The owner of the trust anchor is always a controller.</p> python-ndnNDNts <pre><code>from datetime import datetime, timedelta, timezone\nimport ndn.encoding as enc\nimport ndn.security as sec\nimport ndn.app_support.security_v2 as secv2\nfrom Cryptodome.PublicKey import ECC\nfrom Cryptodome.Random import get_random_bytes\n\n\n# Generate trust anchor of admin\nadmin_priv = ECC.generate(curve='ed25519')\nadmin_pub = admin_priv.public_key()\nadmin_pub_bits = admin_pub.export_key(format='DER')\nadmin_identity_name = enc.Name.from_str('/lab/admin')\n# Key name is &lt;IdentityName&gt;/KEY/&lt;keyId&gt;, here we use random value as key ID.\n# You can also use timestamp, sequencial number, or hash.\nadmin_key_name = enc.Name.normalize(\n    admin_identity_name + ['KEY', enc.Component.from_bytes(get_random_bytes(8))])\n# Self signer is used to sign the self-signed certificate only.\nadmin_self_signer = sec.Ed25519Signer(\n    admin_key_name, admin_priv.export_key(format='DER'))\nanchor_name, anchor = secv2.self_sign(\n    admin_key_name, admin_pub_bits, admin_self_signer)\n# We create a new signer with this certificate's name for further use\nadmin_signer = sec.Ed25519Signer(\n    anchor_name, admin_priv.export_key(format='DER'))\nprint(f'Admin trust anchor name: {enc.Name.to_str(anchor_name)}')\nprint(f'Admin trust anchor hex: {bytes(anchor).hex()}')\nprint()\n\n# Generate the student's key and issue him a certificate\nstu_priv = ECC.generate(curve='ed25519')\nstu_pub = stu_priv.public_key()\nstu_pub_bits = stu_pub.export_key(format='DER')\nstu_identity_name = enc.Name.from_str('/lab/student/xinyu.ma')\nstu_key_name = enc.Name.normalize(\n    stu_identity_name + ['KEY', enc.Component.from_bytes(get_random_bytes(8))])\nstu_cert_name, stu_cert = secv2.new_cert(\n    stu_key_name,\n    'admin',\n    stu_pub_bits,\n    admin_signer,\n    start_time=datetime.now(timezone.utc),\n    end_time=datetime.now(timezone.utc) + timedelta(days=365),\n)\nstu_signer = sec.Ed25519Signer(\n    stu_cert_name, stu_priv.export_key(format='DER'))\nprint(f'Student certificate name: {enc.Name.to_str(stu_cert_name)}')\nprint(f'Student certificate hex: {bytes(stu_cert).hex()}')\nprint()\n\n# Sign the paper's data with the student's certificate\ndata_wire = enc.make_data(\n    name='/lab/paper/ndn/change/1',\n    meta_info=enc.MetaInfo(freshness_period=10000),\n    content=b'Hello, NDN!',\n    signer=stu_signer\n)\nprint('Data:', data_wire.hex())\n</code></pre> <pre><code>import { Component, Data, Name } from '@ndn/packet';\nimport { Encoder } from '@ndn/tlv';\nimport { toHex, toUtf8 } from '@ndn/util';\nimport { Certificate, Ed25519, generateSigningKey, ValidityPeriod } from '@ndn/keychain';\n\n// Generate trust anchor of admin\nconst adminIdentityName = new Name('/lab/admin');\nconst [adminSelfSigner, adminVerifier] = await generateSigningKey(adminIdentityName, Ed25519);\nconst anchor = await Certificate.selfSign({\n  privateKey: adminSelfSigner,\n  publicKey: adminVerifier,\n});\nconst adminSigner = adminSelfSigner.withKeyLocator(anchor.name);\nconst anchorWire = Encoder.encode(anchor.data);\nconsole.log(`Admin trust anchor name: ${anchor.name.toString()}`);\nconsole.log(`Admin trust anchor hex: ${toHex(anchorWire)}`);\nconsole.log('');\n// The following line create the verifier from certificate\n// const anchor = Certificate.fromData(Decoder.decode(anchorWire, Data));\n// const adminVerifier = await createVerifier(anchor, {algoList: [Ed25519]});\n\n// Generate the student's key and issue him a certificate\nconst stuIdentityName = new Name('/lab/student/xinyu.ma');\nconst [stuSelfSigner, stuVerifier] = await generateSigningKey(stuIdentityName, Ed25519);\nconst stuCert = await Certificate.issue({\n  issuerPrivateKey: adminSigner,\n  publicKey: stuVerifier,\n  issuerId: new Component(8, 'admin'),\n  // Equivalent to the following:\n  // validity: new ValidityPeriod(Date.now(), Date.now() + 365 * 86400000),\n  validity: ValidityPeriod.daysFromNow(365),\n});\nconst stuSigner = stuSelfSigner.withKeyLocator(stuCert.name);\nconst stuCertWire = Encoder.encode(stuCert.data);\nconsole.log(`Student certificate name: ${stuCert.name.toString()}`);\nconsole.log(`Student certificate hex: ${toHex(stuCertWire)}`);\nconsole.log('');\n\n// Sign the paper's data with the student's certificate\nconst data = new Data(\n  new Name('/lab/paper/ndn/change/1'),\n  Data.FreshnessPeriod(10000),\n  toUtf8('Hello, NDN!'),\n);\nawait stuSigner.sign(data);\nconst dataWire = Encoder.encode(data);\nconsole.log('Data:', toHex(dataWire));\n</code></pre> <p>An application may involve multiple trust domains. Inter-domain trust relations will be established by the controller. In the case where pure peer-to-peer trust relation is established, every member is its own controller.</p> <p>Trust Zone</p> <p>A trust domain has also been called a trust zone in some papers, not to be confused with the hardware trust zone.</p>"},{"location":"ndn-security/#trust-schema","title":"Trust Schema","text":"<p>TBD</p>"},{"location":"ndn-security/#full-name","title":"Full Name","text":"<p>The full name of a Data packet is the name of the Data appended with a ImplicitSha256Digest component. The digest component contains a SHA256 hash of the whole packet. Therefore, if the consumer securely obtains the full name of a packet, it can verifies the integrity by simply computing its hash digest, without knowing any key.</p> <p>This is useful for bootstrapping: one can learn the full name of the new member's certificate out-of-band, and then fetch the it through some non-secure channel.</p> <p>(Code snippet to be added)</p>"},{"location":"packets/","title":"Packet Types","text":"<p>At a high level, NDN defines two distinct types of packets:</p> <ul> <li>Interest packets are used to request data from the network. The most important component of an Interest packet is the name of the data being requested. An Interest may contain additional parameters such as a lifetime or hop limit, which are referred to as selectors.</li> <li>Data packets carry the actual data being requested, along with the name of the Data and a cryptographic signature. On receiving an Interest packet, nodes in the network may respond with a Data matching the name in the Interest.</li> </ul> <p>How are NDN packets used?</p> <p>Interest and Data packets are used in a request-response fashion. An NDN application sends an Interest packet to request data from the network, and receives a single Data packet in response.</p> <p>The following example illustrates the basic structure of Interest and Data packets.</p> <pre><code>classDiagram\n  Interest &lt;|-- Data\n  class Interest{\n    Name = /edu/ucla/cs/118/notes\n    Lifetime = 5000 ms\n  }\n  class Data{\n    Name = /edu/ucla/cs/118/notes\n    Content = \"Hello, NDN!\"\n    Signature = 3046022100e773b\n  }</code></pre> <p><code>CanBePrefix</code> Interest Selector</p> <p>In this example, the name of the Interest and Data packets is an exact match. If the <code>CanBePrefix</code> selector is specified on the Interest, the name of a matching Data packet may be longer than the name of the Interest packet, as long as it has the name of the Interest as a prefix.</p> <p>Data Signing</p> <p>It is important to note that a Data packet is required to carry a signature to be considered valid.</p>"},{"location":"packets/#tlv-encoding","title":"TLV Encoding","text":"<p>On the wire, NDN packets are represented using the Type-Length-Value (NDN TLV<sup>1</sup>) encoding scheme. TLV is a highly efficient binary encoding scheme that supports variable length fields and nested structures.</p> <p>Each field in the packet is encoded as a TLV element, which consists of a type, length, and value. The type and length fields are encoded as variable length integers, and the value field is encoded as a sequence of bytes (which in turn may be another TLV block). Interest and Data packets themselves are also encoded as TLV elements.</p> <p>The following example illustrates the TLV encoding of the Interest and Data packets shown above. The type of the block is specified first (in red, hover for numeric), followed by the length (in blue) and the value.</p> <p>Encoding of Names</p> <p>NDN names are hierarchical and are encoded as a list of components. Each component is treated as an opaque binary value by the network, and may contain any sequence of bytes with no restrictions. For readability, names may be represented using the NDN URI Scheme using slashes as delimiters between components.</p> <p>Packet Format Specification</p> <p>The formal specification for Interest and Data packets and TLV encoding can be accessed here.</p>"},{"location":"packets/#library-functions","title":"Library Functions","text":"<p>This section describes how to encode Interest and Data packets using some of the NDN client libraries. The next page will describe how to use the libraries to send and receive the packets.</p> ndn-cxxpython-ndnNDNts <pre><code>#include &lt;ndn-cxx/face.hpp&gt;\n\nint main(int argc, char** argv)\n{\n    // Create an NDN Name from a URI string\n    ndn::Name name(\"/edu/ucla/cs/118/notes\");\n\n    // Create an Interest packet with this name\n    ndn::Interest interest(name);\n\n    // Set the Interest packet's InterestLifetime to 5 seconds\n    interest.setInterestLifetime(ndn::time::seconds(5));\n\n    // Create a Data packet with the same name\n    ndn::Data data(name);\n\n    // Set the Data packet's content to \"Hello, NDN!\"\n    data.setContent(ndn::make_span(reinterpret_cast&lt;const uint8_t*&gt;(\"Hello, NDN!\"), 11));\n}\n</code></pre> <pre><code>import ndn.encoding as enc\nimport ndn.security as sec\n\n#  Create an Interest packet with its NDN name from a URI string\ninterest_wire = enc.make_interest(\n    enc.Name.from_str('/edu/ucla/cs/118/notes'),\n    # Set the Interest packet's InterestLifetime to 5 seconds\n    enc.InterestParam(lifetime=5000),\n)\nprint(interest_wire.hex())\n# In python-ndn you do not have to encode the Interest manually.\n# NDNApp's express function provides a more flexible API to send an Interest directly.\n\n# Create a SHA256 digest signer\ndigest_signer = sec.DigestSha256Signer()\n# Create a Data packet with the same name\ndata_wire = enc.make_data(\n    # String can be directly used as Name in most cases\n    name='/edu/ucla/cs/118/notes',\n    # Set the Interest packet's FreshnessPeriod to 10 seconds\n    meta_info=enc.MetaInfo(freshness_period=10000),\n    # Set the Data packet's content to \"Hello, NDN!\"\n    content=b'Hello, NDN!',\n    signer=digest_signer\n)\nprint(data_wire.hex())\n</code></pre> <pre><code>import { Name, Interest, Data } from '@ndn/packet';\nimport { toUtf8 } from '@ndn/util';\n\n// Create an NDN name from a URI string\nconst name = new Name('/edu/ucla/cs/118/notes');\n\n// Create an Interest packet with this name\nconst interest = new Interest(name);\n\n// Set the Interest packet's InterestLifetime to 5 seconds\ninterest.lifetime = 5000;\n\n// Create a Data packet with the same name\nconst data = new Data(name);\n\n// Set the Data packet's content to \"Hello, NDN!\"\ndata.content = toUtf8('Hello, NDN!');\n</code></pre> <ol> <li> <p>Ma, X. et al. 2022. A type-theoretic model on NDN-TLV encoding. Proceedings of the 9th ACM conference on information-centric networking (New York, NY, USA, 2022), 91\u2013102.\u00a0\u21a9</p> </li> </ol>"},{"location":"routing/","title":"Routing","text":"<p>This page is under construction.</p>"},{"location":"storage/","title":"Storage","text":"<p>Persistent storage is a key component of application functionality. In the NDN philosophy, highly available storage is provided as part of the network infrastructure. This allows applications to store data in the network, and to retrieve it from the network, without needing to rely on a separate storage service.</p> <p>Generally speaking, there are three kinds of storage services in NDN. We describe each of these in further detail below.</p> <ul> <li>Application Storage: storage used by a particular application instance.</li> <li>Data Repository: a persistent general-purpose storage deployed in the network.</li> <li>Content Store: a passive cache configured in all NDN forwarders.</li> </ul> <p>General purpose storage</p> <p>By design, NDN data stores are typically not application-specific, being provided as a service by the network infrastructure. This is in contrast to traditional cloud storage services, which are provided by third-party vendors and require applications to adapt to their specific APIs. Since data is secured independently of the transport and storage, the stored data is always secured at rest and in transit.</p>"},{"location":"storage/#application-storage","title":"Application Storage","text":"<p>Individual NDN applications typically require local storage for the data at a particular instance. This may include data that has been produced by the application, or data that has been fetched from the network. The application storage is typically managed by the application itself, and is not shared with other applications.</p> <p>NDN libraries provide APIs for applications to store and retrieve data from local storage using the name. The storage itself may be implemented using memory or disk, and may store either the raw Data packets or the application-specific data structures.</p> ndn-cxx <pre><code>#include &lt;cassert&gt;\n#include &lt;ndn-cxx/ims/in-memory-storage-persistent.hpp&gt;\n#include &lt;ndn-cxx/security/key-chain.hpp&gt;\n\nint main(int argc, char** argv)\n{\n    // Create an in-memory application-specific storage\n    ndn::InMemoryStoragePersistent ims;\n\n    // Create and sign a data packet\n    auto data = std::make_shared&lt;ndn::Data&gt;(\"/test/data\");\n    data-&gt;setContent(\"Hello, World!\");\n    ndn::KeyChain keyChain;\n    keyChain.sign(*data);\n\n    // Insert a data packet into the store\n    ims.insert(*data);\n\n    // Find a data packet in the store\n    ndn::Interest interest(\"/test/data\");\n    assert(ims.find(interest)-&gt;getName() == data-&gt;getName());\n}\n</code></pre>"},{"location":"storage/#data-repository","title":"Data Repository","text":"<p>Imagine the following scenario: an application uses some public online storage to store its data. To make sure the online storage stores the data faithfully, every uploaded file is signed. The application provider does not need to operate the storage, nor do they need to pay for it: the users will use their own quota and pay themselves. To make sure data are available in case when the storage is down, users also have local copies of their data.</p> <p>In this scenario, the role of the online storage plays a role similar to a Repo in NDN networks in some aspects but different in others.</p> <ul> <li>The similarities<ul> <li>General-purpose: the storage is not designed for specific application and not operated by application teams. The storage do not run application logic.</li> <li>Untrusted: the storage is not trusted in the application's trust domains. It has its own trust relationship with producers who upload data to it, but this is not related to the application. The storage is not allowed to produce any data for the application.</li> <li>Rendezvous point: when peers cannot be online simultaneously, the repo makes data available.</li> </ul> </li> <li>The differences<ul> <li>The cloud storage has its own API. However, in the NDN world, data fetching is done by stardard Interest-Data exchange. Data consumers will notice the existence of Repo, ideally.</li> <li>Different cloud providers typically cannot collaborate with each other, and the application developers have to pick some providers and adapt for them. NDN applications do not have to adapt for specific Repo providers.</li> </ul> </li> </ul>"},{"location":"storage/#content-store","title":"Content Store","text":"<p>The content store is an ephemeral cache in each NDN forwarder in the network, which stores the most recently or frequently requested data. Unlike the other storage types described above, the application does not exercise any control over the data stored in the content store. Further the content store does not provide any guarantess on cache eviction or availability, and thus should not be relied upon for long-term storage.</p> <p>Data Immutability</p> <p>Since any forwarder in the network may cache data for any duration of time, applications must not rely on a given Data packet eventually being unavailable. Each Data packet must be treated as immutable and potentially available forever, and thus names must not be reused.</p> <p>Clearing the content store</p> <p>During application development, the content store may lead to unexpected behavior, e.g. data that has not been produced yet may be available from a previous test run. In such situations, you may want to clear the cache using the <code>nfdc</code> command-line tool.</p> <pre><code>nfdc cs erase /&lt;prefix&gt;  # erase all cached data under a prefix\n</code></pre>"},{"location":"sync/","title":"Sync Transport","text":"<p>This page is under construction.</p>"},{"location":"testbed/","title":"Research Testbed","text":"<p>This page is under construction.</p> <p>The NDN research testbed is a shared resource created for research purposes, that include software routers at several participating institutions, application host nodes, and other devices. The testbed is used for research and development of NDN software, and for experiments that require a shared NDN infrastructure. It is not intended for production use.</p> <p>https://named-data.net/ndn-testbed/</p>"},{"location":"testbed/#obtain-a-testbed-certificate","title":"Obtain a testbed certificate","text":"<p>See User Guide to Obtain a Testbed Certificate</p>"},{"location":"testbed/#connect-to-testbed-using-local-nfd","title":"Connect to testbed using local NFD","text":"<p>TBD</p>"},{"location":"testbed/#connect-to-testbed-from-application","title":"Connect to testbed from application","text":"<p>TBD</p>"}]}